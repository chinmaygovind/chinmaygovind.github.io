<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Ball Roll Game</title>
  <style>
    body { margin: 0; overflow: hidden; background: #222; }
    #info { position: absolute; top: 10px; left: 10px; color: #fff; font-family: sans-serif; z-index: 1; }
  </style>
</head>
<body>
  <div id="info">Use WASD or Arrow Keys to roll the ball</div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/controls/PointerLockControls.js"></script>
  <script>
    // Gemini API key (replace with your actual key)
    const GEMINI_API_KEY = "AIzaSyAhA3-NkCvCeAFKUZYkz12Jc9k3dpTBQNE";
    const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent";

    let scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222233);
    let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    let renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting
    let light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 10, 7.5);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x8888aa));

    // Floor (make world much larger)
    let floorGeo = new THREE.PlaneGeometry(1000, 1000);
    let floorMat = new THREE.MeshPhongMaterial({color: 0x228822});
    let floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI/2;
    floor.position.y = -1;
    floor.receiveShadow = true;
    scene.add(floor);

    // Ball
    let ballGeo = new THREE.SphereGeometry(1, 32, 32);
    let ballMat = new THREE.MeshPhongMaterial({color: 0xff4444});
    let ball = new THREE.Mesh(ballGeo, ballMat);
    ball.position.set(0, 1, 0);
    ball.castShadow = true;
    scene.add(ball);

    // --- Town Elements ---
    // Roads
    function addRoad(x, z, w, l, rot=0) {
      let roadGeo = new THREE.BoxGeometry(w, 0.1, l);
      let roadMat = new THREE.MeshPhongMaterial({color: 0x444444});
      let road = new THREE.Mesh(roadGeo, roadMat);
      road.position.set(x, -0.95, z);
      road.rotation.y = rot;
      scene.add(road);
    }
    // Main road
    addRoad(0, 0, 10, 200); // vertical
    addRoad(0, 0, 200, 10); // horizontal
    // Side roads
    addRoad(-40, 30, 8, 60);
    addRoad(40, -30, 8, 60);

    // Trees
    function addTree(x, z) {
      let trunkGeo = new THREE.CylinderGeometry(0.5, 0.7, 3, 8);
      let trunkMat = new THREE.MeshPhongMaterial({color: 0x8B5A2B});
      let trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.set(x, 0.5, z);
      scene.add(trunk);
      let leavesGeo = new THREE.SphereGeometry(2, 16, 16);
      let leavesMat = new THREE.MeshPhongMaterial({color: 0x228B22});
      let leaves = new THREE.Mesh(leavesGeo, leavesMat);
      leaves.position.set(x, 3, z);
      scene.add(leaves);
    }
    for (let i = -80; i <= 80; i += 20) {
      addTree(i, -50);
      addTree(i, 50);
      addTree(-50, i);
      addTree(50, i);
    }
    // Random trees
    for (let i = 0; i < 20; i++) {
      let x = Math.random() * 180 - 90;
      let z = Math.random() * 180 - 90;
      addTree(x, z);
    }

    // Buildings
    function addBuilding(x, z, w, h, d, color) {
      let geo = new THREE.BoxGeometry(w, h, d);
      let mat = new THREE.MeshPhongMaterial({color});
      let mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(x, h/2 - 1, z);
      scene.add(mesh);
    }
    // Unique buildings
    addBuilding(-30, -30, 12, 18, 12, 0x2196f3); // Blue tower
    addBuilding(30, 30, 18, 8, 10, 0xff9800); // Orange house
    addBuilding(-40, 40, 10, 12, 16, 0x9c27b0); // Purple shop
    addBuilding(40, -40, 14, 14, 14, 0x4caf50); // Green block
    // More buildings
    for (let i = -60; i <= 60; i += 30) {
      addBuilding(i, 20, 8, 6 + Math.random()*10, 8, 0xbdbdbd);
      addBuilding(i, -20, 8, 6 + Math.random()*10, 8, 0x795548);
    }
    for (let i = -60; i <= 60; i += 30) {
      addBuilding(20, i, 8, 6 + Math.random()*10, 8, 0x607d8b);
      addBuilding(-20, i, 8, 6 + Math.random()*10, 8, 0xf44336);
    }

    // Camera follows ball
    camera.position.set(0, 4, 8);
    camera.lookAt(ball.position);

    // --- NPCs (People) ---
    let npcs = [];
    let npcMessages = [
      "Welcome to our town!",
      "Nice rolling skills!",
      "Have you visited the blue tower?",
      "The trees are lovely today.",
      "Try rolling down the main road!",
      "I love this orange house.",
      "Watch out for buildings!",
      "Enjoy your stay!"
    ];
    function addNPC(x, z, color, message) {
      // Body
      let bodyGeo = new THREE.SphereGeometry(1, 16, 16);
      let bodyMat = new THREE.MeshPhongMaterial({color});
      let body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.set(x, 1, z);
      scene.add(body);
      // Head
      let headGeo = new THREE.SphereGeometry(0.6, 16, 16);
      let headMat = new THREE.MeshPhongMaterial({color: 0xfff9c4});
      let head = new THREE.Mesh(headGeo, headMat);
      head.position.set(x, 2.1, z);
      scene.add(head);
      // Eyes
      let eyeGeo = new THREE.SphereGeometry(0.13, 8, 8);
      let eyeMat = new THREE.MeshPhongMaterial({color: 0x222222});
      let eyeL = new THREE.Mesh(eyeGeo, eyeMat);
      let eyeR = new THREE.Mesh(eyeGeo, eyeMat);
      eyeL.position.set(x - 0.18, 2.25, z + 0.38);
      eyeR.position.set(x + 0.18, 2.25, z + 0.38);
      scene.add(eyeL);
      scene.add(eyeR);
      npcs.push({mesh: body, head, eyeL, eyeR, dir: Math.random() * Math.PI * 2, speed: 0.012 + Math.random()*0.015, message});
    }
    for (let i = 0; i < 8; i++) {
      let x = Math.random() * 120 - 60;
      let z = Math.random() * 120 - 60;
      let color = 0xffe082 + i*0x111111;
      addNPC(x, z, color, npcMessages[i % npcMessages.length]);
    }

    // Dialog box
    let dialog = document.createElement('div');
    dialog.style.position = 'absolute';
    dialog.style.bottom = '40px';
    dialog.style.left = '50%';
    dialog.style.transform = 'translateX(-50%)';
    dialog.style.background = 'rgba(30,30,30,0.95)';
    dialog.style.color = '#fff';
    dialog.style.padding = '16px 32px';
    dialog.style.borderRadius = '12px';
    dialog.style.fontFamily = 'sans-serif';
    dialog.style.fontSize = '1.2em';
    dialog.style.display = 'none';
    dialog.style.zIndex = '2';
    document.body.appendChild(dialog);
    let talkingTo = null;
    let conversation = [];
    // Input for user reply
    let replyBox = document.createElement('input');
    replyBox.type = 'text';
    replyBox.placeholder = 'Type your message...';
    replyBox.style.width = '80%';
    replyBox.style.marginTop = '12px';
    replyBox.style.fontSize = '1em';
    replyBox.style.padding = '8px';
    replyBox.style.borderRadius = '6px';
    replyBox.style.border = 'none';
    replyBox.style.outline = 'none';
    let sendBtn = document.createElement('button');
    sendBtn.textContent = 'Send';
    sendBtn.style.marginLeft = '8px';
    sendBtn.style.padding = '8px 16px';
    sendBtn.style.fontSize = '1em';
    sendBtn.style.borderRadius = '6px';
    sendBtn.style.border = 'none';
    sendBtn.style.background = '#2196f3';
    sendBtn.style.color = '#fff';
    sendBtn.style.cursor = 'pointer';

    function showDialog(npc, message) {
      dialog.innerHTML = `
        <form id='npcDialogForm' style='margin:0;'>
          <div style='background:rgba(50,50,50,0.95);padding:12px 18px;border-radius:8px;margin-bottom:18px;font-size:1.1em;'>
            ${message}
          </div>
          <div style='display:flex;align-items:center;justify-content:center;'>
            <input id='replyBox' type='text' autocomplete='off' placeholder='Type your message...' style='width:70%;margin-right:8px;font-size:1em;padding:8px;border-radius:6px;border:none;outline:none;'>
            <button id='sendBtn' type='submit' style='padding:8px 16px;font-size:1em;border-radius:6px;border:none;background:#2196f3;color:#fff;cursor:pointer;'>Send</button>
          </div>
        </form>
      `;
      dialog.style.display = 'block';
      setTimeout(() => {
        let replyInput = document.getElementById('replyBox');
        let sendButton = document.getElementById('sendBtn');
        let form = document.getElementById('npcDialogForm');
        if (replyInput) {
          replyInput.value = '';
          replyInput.focus();
          replyInput.disabled = false;
          replyInput.readOnly = false;
        }
        if (form) {
          form.onsubmit = async function(e) {
            e.preventDefault();
            let userMsg = replyInput.value.trim();
            if (!userMsg || !talkingTo) return;
            replyInput.value = '';
            // Add user message to conversation
            conversation.push({user: userMsg, npc: ''});
            showDialog(talkingTo, 'Thinking...');
            // Build Gemini request
            let contents = [];
            for (let turn of conversation) {
              if (turn.user) contents.push({parts: [{text: turn.user}]});
              if (turn.npc) contents.push({parts: [{text: turn.npc}]});
            }
            let payload = { contents };
            try {
              let res = await fetch(GEMINI_API_URL + '?key=' + GEMINI_API_KEY, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
              });
              let data = await res.json();
              let npcReply = data?.candidates?.[0]?.content?.parts?.[0]?.text || '...';
              conversation[conversation.length-1].npc = npcReply;
              showDialog(talkingTo, npcReply);
            } catch (err) {
              showDialog(talkingTo, 'Error talking to Gemini API.');
            }
          };
        }
      }, 100);
    }

    // Talk hint
    let talkHint = document.createElement('div');
    talkHint.style.position = 'absolute';
    talkHint.style.bottom = '100px';
    talkHint.style.left = '50%';
    talkHint.style.transform = 'translateX(-50%)';
    talkHint.style.background = 'rgba(30,30,30,0.8)';
    talkHint.style.color = '#fff';
    talkHint.style.padding = '6px 18px';
    talkHint.style.borderRadius = '8px';
    talkHint.style.fontFamily = 'sans-serif';
    talkHint.style.fontSize = '1em';
    talkHint.style.display = 'none';
    talkHint.style.zIndex = '2';
    document.body.appendChild(talkHint);

    // Ball physics
    let velocity = new THREE.Vector3();
    let acceleration = 0.025; // even slower ball
    let friction = 0.96; // more friction, slower
    let keys = {};

    document.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
    document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

    function animate() {
      requestAnimationFrame(animate);
      // Controls
      let dir = new THREE.Vector3();
      if (keys['w'] || keys['arrowup']) dir.z -= 1;
      if (keys['s'] || keys['arrowdown']) dir.z += 1;
      if (keys['a'] || keys['arrowleft']) dir.x -= 1;
      if (keys['d'] || keys['arrowright']) dir.x += 1;
      if (dir.length() > 0 && !talkingTo) {
        dir.normalize();
        velocity.x += dir.x * acceleration;
        velocity.z += dir.z * acceleration;
      }
      // Friction
      velocity.multiplyScalar(friction);
      // Move ball
      ball.position.add(velocity);
      // Stay above floor
      ball.position.y = 1;
      // Camera follows
      camera.position.lerp(new THREE.Vector3(ball.position.x, ball.position.y + 3, ball.position.z + 8), 0.1);
      camera.lookAt(ball.position);

      // NPC movement
      for (let npc of npcs) {
        // Only move if not talking to this NPC
        if (talkingTo !== npc) {
          let dx = Math.cos(npc.dir) * npc.speed;
          let dz = Math.sin(npc.dir) * npc.speed;
          npc.mesh.position.x += dx;
          npc.mesh.position.z += dz;
          npc.head.position.x += dx;
          npc.head.position.z += dz;
          npc.eyeL.position.x += dx;
          npc.eyeL.position.z += dz;
          npc.eyeR.position.x += dx;
          npc.eyeR.position.z += dz;
          // Bounce off world edge
          if (Math.abs(npc.mesh.position.x) > 90 || Math.abs(npc.mesh.position.z) > 90) {
            npc.dir += Math.PI;
          }
          // Randomly change direction
          if (Math.random() < 0.01) npc.dir += (Math.random()-0.5)*Math.PI/2;
        }
      }
      // Dialog logic & talk hint
      let found = null;
      for (let npc of npcs) {
        let dist = ball.position.distanceTo(npc.mesh.position);
        if (dist < 3) {
          found = npc;
          break;
        }
      }
      if (found && !talkingTo) {
        talkHint.style.display = 'block';
        talkHint.textContent = 'Press Space to talk';
      } else {
        talkHint.style.display = 'none';
      }
      if (found && talkingTo === found) {
        dialog.style.display = 'block';
        // Show last NPC message and input
        let lastMsg = conversation.length ? conversation[conversation.length-1].npc : found.message;
        showDialog(found, lastMsg);
      } else if (talkingTo) {
        dialog.style.display = 'none';
        talkingTo = null;
        conversation = [];
      }
      renderer.render(scene, camera);
    }
    animate();

    // Talk to NPC
    document.addEventListener('keydown', e => {
      if (e.code === 'Space' && !talkingTo) {
        for (let npc of npcs) {
          let dist = ball.position.distanceTo(npc.mesh.position);
          if (dist < 3) {
            talkingTo = npc;
            dialog.style.display = 'block';
            conversation = [{user: '', npc: npc.message}];
            showDialog(npc, npc.message);
            talkHint.style.display = 'none';
            break;
          }
        }
      }
      if (e.code === 'Escape' && talkingTo) {
        dialog.style.display = 'none';
        talkingTo = null;
        conversation = [];
      }
    });
    // Send user reply to Gemini
    sendBtn.onclick = async function() {
      let userMsg = replyBox.value.trim();
      if (!userMsg || !talkingTo) return;
      replyBox.value = '';
      // Add user message to conversation
      conversation.push({user: userMsg, npc: ''});
      showDialog(talkingTo, 'Thinking...');
      // Build Gemini request
      let contents = [];
      for (let turn of conversation) {
        if (turn.user) contents.push({parts: [{text: turn.user}]});
        if (turn.npc) contents.push({parts: [{text: turn.npc}]});
      }
      // Last message is from user
      let payload = { contents };
      try {
        let res = await fetch(GEMINI_API_URL + '?key=' + GEMINI_API_KEY, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(payload)
        });
        let data = await res.json();
        let npcReply = data?.candidates?.[0]?.content?.parts?.[0]?.text || '...';
        conversation[conversation.length-1].npc = npcReply;
        showDialog(talkingTo, npcReply);
      } catch (err) {
        showDialog(talkingTo, 'Error talking to Gemini API.');
      }
    };

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
